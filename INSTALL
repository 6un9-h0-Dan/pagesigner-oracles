-------------------------------------------------------------------------------
HOW TO CREATE A PAGESIGNER ORACLE EBS SNAPSHOT.
-------------------------------------------------------------------------------
In N.Virginia region start a t3a.micro instance and attach to it a volume created from
snap-0c97f1c43c6bb2043 (used by Ubuntu 20.04 LTS ami-083654bd07b5da81d).

From within the instance:	
<bash>
  git clone --recurse-submodules https://github.com/tlsnotary/pagesigner-oracles

  sudo -s
  mkdir /mnt/disk
  mount /dev/nvme1n1p1 /mnt/disk
  DISK=/mnt/disk
  rm $DISK/etc/init.d/ssh
  rm $DISK/usr/sbin/sshd

  # change root device
  sed -i 's/root=PARTUUID=3fa6b62f-01/root=\/dev\/nvme0n1p1/' $DISK/boot/grub/grub.cfg 
  # disable cloudinit modules through which user data can potentially be passed to the instance
  sed -i 's/- bootcmd//' $DISK/etc/cloud/cloud.cfg
  sed -i 's/- runcmd//' $DISK/etc/cloud/cloud.cfg
  sed -i 's/- rightscale_userdata//' $DISK/etc/cloud/cloud.cfg
  sed -i 's/- scripts-user//' $DISK/etc/cloud/cloud.cfg
  sed -i 's/- ssh//' $DISK/etc/cloud/cloud.cfg

  mkdir -p $DISK/home/ubuntu/server
  cp -R pagesigner-oracles/server $DISK/home/ubuntu
  cp -R pagesigner-oracles/systemd $DISK/root

  cp pagesigner-oracles/systemd/tlsnotary_* $DISK/etc/systemd/system/
  #make services start on boot
  ln -s /etc/systemd/system/tlsnotary_server.service $DISK/etc/systemd/system/graphical.target.wants/
  ln -s /etc/systemd/system/tlsnotary_server.path $DISK/etc/systemd/system/graphical.target.wants/
  ln -s /etc/systemd/system/tlsnotary_setup.service $DISK/etc/systemd/system/graphical.target.wants/

  umount /dev/nvme1n1p1
</bash>
		
In AWS console: 
- detach the volume
- create a public snapshot
- create an image from the snapshot
- note the AMI ID and make the AMI public.


-------------------------------------------------------------------------------
HOW TO LAUNCH AN ORACLE INSTANCE FROM THE PUBLIC SNAPSHOT.
-------------------------------------------------------------------------------
Launch the AMI you created from AWS management console. Choose "Proceed without a key pair".

Make sure that:
  Instance's "launchTime" and volume's "attachTime" happened on the same minute
  with no more than 2 seconds between the events.
  Console Output (right-click an instance ->Instance Settings -> Get System Log)
  is available (after ~5 mins)

-------------------------------------------------------------------------------
HOW TO PROVE THAT A CERTAIN IP ADDRESS IS RUNNING THE ORACLE INSTANCE
-------------------------------------------------------------------------------
Use aws_query.py to create and publish URLs for requests 
DescribeInstances
DescribeInstanceAttribute (userData, kernel, ramdisk)
DescribeVolumes
DescribeImages
GetUser
GetConsoleOutput


-------------------------------------------------------------------------------
FOR VERIFIERS: HOW TO CHECK THAT THE SNAPSHOT CONTENTS WAS NOT MALICIOUSLY MODIFIED.
-------------------------------------------------------------------------------
Repeat all the steps described in "HOW TO CREATE AN ORACLE EBS SNAPSHOT" but don't create a public snapshot.
Attach the resulting volume (volX) to a running instance as /dev/sdg
Create a volume from the snapshot (volY) you are verifying and attach it to /dev/sdh
After that, run from within the instance
<bash>
  sudo -s
  fsck /dev/xvdg1
  fsck /dev/xvdh1
  #fsck must show that there were no errors
  mkdir /mnt/disk1
  mkdir /mnt/disk2
  mount /dev/xvdg1 /mnt/disk1
  mount /dev/xvdh1 /mnt/disk2
</bash>
 
Compare the hashes of volX and volY. 
First hash file/directory/symlink paths, ownership, permissions, and symlink targets.
Then hash the contents of all regular files.
The outputs must match.

Also make sure that MBR and boot sector raw disk data match up to the point where filesystem starts.
Note: we do not check ext4 filesystem headers because they are not deterministic.
fdisk -l /dev/xvdg should show you that you only have 1 partition which starts at sector 2048

<bash>
  cd /mnt/disk1
  find . -printf '%h %f %U %G %m %l\n' | sort -t \n | sha256sum
  find . -type f -print0 | sort -z | xargs -0 sha256sum | sha256sum
  dd if=/dev/xvdg ibs=512 count=2048 | sha256sum

  cd /mnt/disk2
  find . -printf '%h %f %U %G %m %l\n' | sort -t \n | sha256sum
  find . -type f -print0 | sort -z | xargs -0 sha256sum | sha256sum
  dd if=/dev/xvdh ibs=512 count=2048 | sha256sum
</bash>


-------------------------------------------------------------------------------
FOR VERIFIERS: HOW TO DETERMINE THAT THE RUNNING ORACLE INSTANCE IS LEGIT
-------------------------------------------------------------------------------
The published URLs must conform to the checks performed in functions starting with check* in content/oracles.js.


-------------------------------------------------------------------------------
POSSIBLE ATTACKS AND HOW THEY WILL BE MITIGATED
-------------------------------------------------------------------------------
(or in other words, what prevents the AWS account owner from modifying the oracle instance code)


---Attack 1
Launch the AMI with a malicious snapshot on /dev/xvda
---Mitigation:
AWS doesn't allow replacing the snapshotID on the root device.
---Test:
aws ec2 run-instances --image-id ami-08514e4e0cd45a2f4 --block-device-mappings DeviceName=/dev/xvda,Ebs={SnapshotId=snap-0a6ea0aa16e8d63d4}
---Output:
An error occurred (InvalidBlockDeviceMapping) when calling the RunInstances operation: snapshotId cannot be modified on root device


---Attack 2
Launch the AMI with a malicious snapshot on /dev/xvdb hoping that the AMI will boot it instead of /dev/xvda
---Mitgation:
In grub.cfg we changed to root=/dev/xvda1.
---Test:
aws ec2 run-instances --image-id ami-08514e4e0cd45a2f4 --block-device-mappings DeviceName=/dev/xvdb,Ebs={SnapshotId=snap-0a6ea0aa16e8d63d4}
---Output:
After a few minuted check in the System Log that xvda volume was booted and NOT xvdb


---Attack 3
Launch the AMI with /dev/xvda=none and a malicious snapshot on /dev/xvdb, hoping that in the absence of xvda, AMI will boot xvdb.
---Mitigation:
In grub.cfg we changed to root=/dev/xvda1.
---Test:
aws ec2 run-instances --image-id ami-08514e4e0cd45a2f4 --block-device-mappings DeviceName=/dev/xvdb,Ebs={SnapshotId=snap-0a6ea0aa16e8d63d4} DeviceName=/dev/xvda,NoDevice=""
---Output:
After a few minuted check in the System Log:
ALERT!  /dev/xvda1 does not exist.  Dropping to a shell!


---Attack 4
Launch AMI with user data passed in.
---Mitigation:
Since AWS doesn't allow to modify user data while the instance is running, the only way to pass it is during launch.
DescribeInstanceAttribute userData API call will reveal that data was passed in at launch.
On top of that, we removed the bootcmd module from AMI's cloud-init. This module is responsible for handling the user Data.
---Test:
Create a simple script:
printf '#!/bin/bash\necho "HELLO FROM USERDATA"' > script
Run stock AMI with user data passed in:
aws ec2 run-instances --image-id ami-04b9e92b5572fa0d1 --user-data file://script
Run oracle AMI with user data passed in:
aws ec2 run-instances --image-id ami-08514e4e0cd45a2f4 --user-data file://script
--Output:
User data in oracle AMI MUST NOT be visible in System Log as opposed to stock AMI.


---Attack 5:
Start a new snapshot with malicious content. Create an AMI from it. Complete the snapshot with the correct content.
---Mitigation:
AWS does not allow to create AMIs from snapshots in "pending" state.
---Test:
aws ebs start-snapshot --volume-size 8
# Output will have a line "SnapshotId": "snap-0a1ddfc3fbd47ab98"
aws ec2 register-image --root-device-name /dev/xvda --name test --block-device-mappings DeviceName=/dev/xvda,Ebs={SnapshotId=snap-0a1ddfc3fbd47ab98}
---Output:
An error occurred (IncorrectInstanceState) when calling the RegisterImage operation: Snapshot 'snap-0d6c2afe1cc8668bf is not 'completed'